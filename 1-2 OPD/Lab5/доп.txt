Реализовать ввод с клавиатуры до введения стоп-символа, после окончания ввода вывести все введенное на текстовый 
принтер в обратном порядке.Все остальное согласно основному заданию.

Основные проблема:
1) Проблема быстрого ввода с клавиатуры -- это не решить в асинхроном режими обмена
2) Проблема обратного считывния из памяти (непонятно куда будет указывать res) -- Блестяще решено!

------------------------------------------ДОП------------------------------------------

; ------------------ Ввод с клавиатуры (ВУ-8) ------------------
        ORG     0x1F3   ; Начинем программу
res:    WORD    0x5C3   ; Адрес результата
finish: WORD    0x0A    ; Стоп-символ
temp:   WORD    ?       ; Временная ячейка для записи символов
cnt:    WORD    0x0     ; Кол-во символов
bitmsk:	WORD	0x00FF	; битмаска для обнуления старшего байта

START:  CLA
in1:    IN 0x19         ; Ожидание ввода нечётного символа
        AND #0x40       ; Зануляем все биты, кроме 6-ого
        BEQ in1         ; Если AC=0, то ВУ-3 не готово к обмену
        LD (cnt)+       ; Увеличиваем кол-во числе на 1
        IN 0x18	        ; Ввод байта в AC
        ST (res)        ; Загружаем в результат значение нечётного символа
chek1:	CMP finish	; Проверяем на стоп-слово
	BEQ exit_	; Выходим если AC равен стоп-слову
in2:    IN 0x19		; Ожидание ввода чётного символа
        AND #0x40	; Зануляем все кроме 6-го бита 
        BEQ in2		; Если не готово, то возвращаемся к ожиданию
        LD (cnt)+       ; Увеличиваем кол-во числе на 1
        IN 0x18		; Ввод байта в AC
        ST temp		; Загружаем значение чётного байта во временную ячейку
        SWAB		; Загружаем в результат чётный байт	
        OR (res)	; Загружаем в результат чётный байт	
        ST (res)	; Загружаем в результат чётный байт	
chek2:	LD temp		;
	CMP finish	;
        BEQ exit	;
        LD (res)+	; увеличиваем ссылку на 1 
        JUMP in1	; Возвращаемся к вводу нового символа

exit_:  LD -(res)       ; Уменьшаем ссылку на 1 так как нам нужно чтобы сслыка указывала на сразу на символы, а не на стоп-слово
exit:	LD -(cnt)       ; Уменьшаем кол-во символов, так как конец ввода - это не символ изначальной последовательности

; ------------------ Вывод на принтер (ВУ-5) ------------------
        LD cnt          ; Загружаем в AC кол-во символов
        AND #0x1        ; Обнуляем всё кроме первого бита
        BEQ out2        ; Если получаем AC = 0, то число чётно и мы прыгаем на out2

out1:	IN 0xD		; Ожидание разрешения на ввод нечётного символа
        AND #0x40	; Зануляем все биты, кроме 6-ого
        BEQ out1	; Если AC=0, то ВУ-5 не готово к обмену
        LD (res)	; Записываем в AC первые два байта слова
        AND bitmsk	; Оставляем только маладший байт
        OUT 0xC		; Выводим на принтер (ВУ-5)
        LD -(res)       ; Просто уменьшаем ссылку на символы на 1
        LD -(cnt)       ; Уменьшаем кол-во символов на 1
        LD cnt          ; Загружаем cnt в AC
	BEQ exit_o	; Выходим если мы вывели все символы (AC = 0)
out2:	IN 0xD		; Ожидание разрешения на ввод чётного символа
        AND #0x40	; Зануляем все биты, кроме 6-ого
        BEQ out2	; Если AC=0, то ВУ-5 не готово к обмену	
        LD (res)	; Вводим четный символ
        SWAB		; Меняем местами старший и младший байты
        AND bitmsk	; Оставляем только маладший байт	
        OUT 0xC		; Выводим на принтер (ВУ-5)
        LD -(cnt)       ; Уменьшаем кол-во символов на 1
        LD cnt          ; Загружаем cnt в AC
        BEQ exit_o	; Выходим если мы вывели все символы (AC = 0)		
        JUMP out1	; Ввыводим новый символ
exit_o:	HLT		;